1. add 2 linked list: similar to merge 2 linked list, keep one variable for carry, get the value of each list, add them, the sum/10 will be he carry on, and sum%10 will be the sum node's value, keep looping till end of each link and carry is zero
2. bubble sort linked list: need to maintain a flag indicating if there is node swapping in previous looping. if yes, we need to iterate the list again until there is no swapping. 
3. delete a node from a linked list: since only the node to be deleted is given, we can't use pre node and next node to delete it. but we can copy its next node's value over and point its next to its next's next. 
4. insertion sort linked list: starting the head of the list, for each node that's smaller than its previous node, we search in all nodes in front of it to find the insertion point. if we don't reset the previous insert point back to head, sometime, we can save a bit comparing with search from head each time.
5. intersection of 2 linked list: first, we need to know the length of each list by looping each till the tail. if the tails are not same, return false. if same, we let the longer list to move (n-m) steps towards tail before moving the 2 lists together to tails, and when their current nodes match, that's the intersection point.
6. detect if a linked list has a cycle: define a fast pointer and a slow pointer. if there is a cycle, the fast pointer will meet the slow one again. if the fast hit null, there is no cycle
7. find the start node of a cycle in a list: still using fast and slow pointer live in No.6. when they meet again, remember the meet node, let the fast pointer start from the meet node, and the slow node start from head, and they move at the same speed, and the node they meet again will be the start node of the cycle. this is from a formula deducted. 