1. add 2 linked list: similar to merge 2 linked list, keep one variable for carry, get the value of each list, add them, the sum/10 will be he carry on, and sum%10 will be the sum node's value, keep looping till end of each link and carry is zero
2. bubble sort linked list: need to maintain a flag indicating if there is node swapping in previous looping. if yes, we need to iterate the list again until there is no swapping. 
3. delete a node from a linked list: since only the node to be deleted is given, we can't use pre node and next node to delete it. but we can copy its next node's value over and point its next to its next's next. 
4. insertion sort linked list: starting the head of the list, for each node that's smaller than its previous node, we search in all nodes in front of it to find the insertion point. if we don't reset the previous insert point back to head, sometime, we can save a bit comparing with search from head each time.
5. intersection of 2 linked list: first, we need to know the length of each list by looping each till the tail. if the tails are not same, return false. if same, we let the longer list to move (n-m) steps towards tail before moving the 2 lists together to tails, and when their current nodes match, that's the intersection point.
6. detect if a linked list has a cycle: define a fast pointer and a slow pointer. if there is a cycle, the fast pointer will meet the slow one again. if the fast hit null, there is no cycle
7. find the start node of a cycle in a list: still using fast and slow pointer live in No.6. when they meet again, remember the meet node, let the fast pointer start from the meet node, and the slow node start from head, and they move at the same speed, and the node they meet again will be the start node of the cycle. this is from a formula deducted. 
8. merge sort linked list: use fast and slow pointer to get the mid of the list, recursively merge sort the left half and right half then merge them (using a dummy node).
9. merge 2 sorted linked list: one way is to take one list as the main list and merge the second one to the main list, and the other way is to merge 2 lists to a new one. both need to create a dummy node.
10. check palindrome of linked list: edge case checking. first get to the middle of the list using fast/slow pointer. reverse the second half list, and then loop through the original head and the reversed half. return false if they are not same.
11. remove duplicate from linked list: set pre node to be head, traverse from head.next to end and compare current node with pre node, if not duplicate, move pre node to its next also move current node; otherwise, keep moving current node to the next node until it is not equal to pre node. we can also save one variable and use node and the pre node and node.next as the current node
12. remove duplicates from linked list: this is to remove all duplicate values from the list. we use recursive way to do it. first check edge cases. then check if the head and its following nodes are duplicates, if yes, keep moving the next node till it's not duplicate, set the head with the result of the removing duplicates from the next node. if head is not duplicate, then set head.next with the result of removing duplicate from the next node.
13. remove the nth node from the end of the list: use 2 pointers, the first pointer move n steps first, and then the second pointer starts, when the first.next == null, the second pointer is just before the node to be deleted. one special case is that when n is same as the list length. so when move first pointer, we need to check if first is null, if yes, we simply remove the head and remove head.next
14. reverse a linked list: 1. recursive way: take the head and remember head.next, recursively reverse head.next. attach head to the head.next as it is now the tail of the reversed list. remember to set head.next to null. 2. non-recursive way: create a helper node and set its next to head. from head.next to end of list, keep inserting each node behind helper. remember to set head.next to null as it will be the tail of the resulting list.
15. reverse a linked list from mth node and nth node, one pass and in-place only: use non-recursive reverse. first create a helper node to link to the front of head, this is for the case m==1 and we need to reverse head. maintain a pre pointer initialized with helper node, and move it to tail for m-1 steps, then insert the following n-m nodes behind the pre node, be careful how to keep the rest of list to the end for each node moving
16. rotate a linked list to the right by k steps: The first solution is a bit tricky. it first loop through the linked list and counts its length, at the end, it links its tail to its head and form a cycle. then it move its head by n-k-1 steps to get to the pre node of the target 'new' head, return the new head and also set the pre.next to null to break the cycle. The second solution is straightforward, use 2 pointers to locate the pre node of kth node from the end, then from there insert node to the front of the list one by one, this also requires a helper node. remember this is not reversing, so can't insert those nodes all after the helper, we should maintain their order behind helper.
17. selection sort a linked list: looping through the list with node current, each time, find the node with min value after current (including current), and swap the value between node current and the min node. complexity is O(n^2)
18. swap paired nodes in a linked list (can't swap values, swap nodes): check edge cases. first create a helper node and set its next to head. maintain 2 pointers, p1 pointing to the pre node of the first node of current pair and p2 points to the pre node of the second node of current pair. the swapping process is a bit error-prone, also remember to check ending condition
