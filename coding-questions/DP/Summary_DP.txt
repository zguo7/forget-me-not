1. buy and sell stock 1: there is 2 ways to do it. first one is to use DP. we define 2 variables, one for local maximum, and the other is global maximum. since there is one trade only. for local, we take the bigger one between move the trade from previous day to today and do the trade on today only, it's local[i] = max(local[i-1] + price[i] - price[i-1], price[i] - price[i-1]), and global[i] = max(global[i-1], local[i]). The second way is non-DP way, since there is only one trade allowed, the maximum should be from selling at highest price after buying at the lowest price. so, we have a variable to track the lowest price, and check the profit from each price against the lowest. maxProfiel = max(maxProfile, price[i] - lowest)
2. climbing stairs: the number of ways to get to nth step is the sum of ways to get to (n-1)th step and ways to get to (n-2)th step, so we have f(n) = f(n-1) + f(n-2) and f(1)=1 and f(2)=2. 
3. Decoding ways: this is another DP problem. number of decoding ways with n numbers, f(n) depends on how the nth number and (n-1)th number decode together or individually. for 00, f(n) =0; for 10, 20 f(n) = f(n-2); for 11-19 or 21-26 f(n) = f(n-1) + f(n-2) as they can decode together or individually; for 01-09 or 27-99 f(n) = f(n-1)
4. maximum subarray: initialize local and global with the first element, then go through the rest of array, for each element, find the local maximum, max(local + num[i], num[i]) and the global max(global, local)
5. maximum product array: maintain 2 local maximum (one max positive, one min negative, which could become max positive with a negative element), and one global maximum. when positive is smaller than negative, we need to swap them.
6. unique paths in a matrix: typical DP problem. path(x,y) = path(x-1,y)+path(x,y-1). first check edge cases, then intialize the first row and first column with 1, as the number of paths for them are all 1. then loop throug the rest of matrix using the aforementioned formula
7. unique paths in a matrix with obstacles: same as No.6. need to check another edge case, when (0,0) is 1, we directly return 0. otherwise, it is same as No.6, just added one check on each element, when the element at (x,y) is 1, set dp(x,y) to be zero.
