1. longest consecutive sequence: the straightforward way is to sort the array first, and then loop one more time and use 2 pointers to keep track of the start and end index and another variable for the maximum consecutive length. the complexity is the sorting part O(nlogn). A better/desired way is to use set and mimic deep search in graph for the longest sequence. first, put all elements to a hashset, then take one element from the set and search on both direction for the longest. each time an element is checked, remove it from set till the set is empty. this way, the complexity is O(n)
2. set all O surrounded by X in a matrix to X: using flood fill way in graph to solve it. first for each O on first/last row and first/last column, apply flood fill because all O adjacent to O on first/last row/column should not be set to X. each time if the element checked is O, we set it to be #, and put the code for the element's (x,y) index to queue for later checking around it. when this done, we go through all elements again and set all O to X, and all # back to O. (when we need to process current element/node later, we usually use queue/stack)

