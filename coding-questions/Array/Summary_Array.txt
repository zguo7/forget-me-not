1. minimum length of sub array with sum bigger than target: maintain a start point, keep adding element to the sum variable from start index, when it's bigger than the target, try to move the start pointer to right by subtract the element at start index from the sum. updating min length. 
2. find missing number from an array: most straightforward way is to loop through the array and compare each element with its index, if they are not same, then return the index. Another not easy to think way is to use bit operation xor, xor 0-n and all elements of the array will get the missing element. same thinking as finding the only single no duplicate element in an array
3. moving zeros to end of an array: keep a pointer for all non-zero elements. looping through the array, move all non-zero elements to front of array, and set the rest of array all as zero
4. find the next permutation: check edge cases first. 1. from the right end, search for the index of the first descending digit, p. then search from the right for the index of the first digit that is bigger than the digit at p, q. swap value of p and q. if p+1< length-1, reverse digits between p+1 and the length-1 (inclusive)
5. plus one: need to maintain a variable for 'carry' (initialized as 1). starting from the last element, when the carry is not zero, add it to the element and take the remainder as the resulting element, carry will be the sum divided by 10, if the carry is zero, we return. when the loop is done, and the carry is not zero, we return an array of size (n+1) and set the first element to be 1. 
6. generate pascal triangle: the first and last element in each row is always 1. element i in row n equals the sum of element i and element i-1 in row n-1. 
7. generate the nth row of pascal triangle: there are n+1 elements in row n, create an array of size n+1, and fill it with 1. we calculate each row on the same array, we calculate from 2nd row (row 3), so looping from 0 to n-1, the calculation should start from i+1 to 1 for the ith row (we don't need to calculate the first and last element in each row, as they are always 1)
8. product exception self: it takes 2 traversing of the array, first looping is from right to left, set each element to be the product of all elements to its right. second looping is from left to right and for each element, times its values with product of all elements to its left
9. remove duplicate from an array: maintain one length pointer initialized to 0, loop through the array starting from index 1, if its' same as the element at length, move the index to next, otherwise, move both indice and set the element at length with the current element
10. remove duplicate from an array, but allow at most 2 duplicates: start from the third element, and compare each element with its previous 2 elements, if all same, ignore current element and move on; otherwise, move the pointer and set it with current element
11. remove all instances of a value from array, maintain 2 indices, one for the values to stay and one for the traversing, current. if the current value doesn't equal to the target, set element at stay with the value at current and move stay to next, otherwise, stay doesn't move
12. 
