1. minimum length of sub array with sum bigger than target: maintain a start point, keep adding element to the sum variable from start index, when it's bigger than the target, try to move the start pointer to right by subtract the element at start index from the sum. updating min length. 
2. find missing number from an array: most straightforward way is to loop through the array and compare each element with its index, if they are not same, then return the index. Another not easy to think way is to use bit operation xor, xor 0-n and all elements of the array will get the missing element. same thinking as finding the only single no duplicate element in an array
3. moving zeros to end of an array: keep a pointer for all non-zero elements. looping through the array, move all non-zero elements to front of array, and set the rest of array all as zero
4. find the next permutation: check edge cases first. 1. from the right end, search for the index of the first descending digit, p. then search from the right for the index of the first digit that is bigger than the digit at p, q. swap value of p and q. if p+1< length-1, reverse digits between p+1 and the length-1 (inclusive)

