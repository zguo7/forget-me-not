1. Is tree balanced: recursive traverse. using a number to represent tree height. -1 is for unbalanced. when left or right is unbalanced, return -1. when height difference between left and right is bigger than 1, return -1; otherwise return max height of left and right plus 1. 
2. Inorder traverse binary tree in non-recursive way: use a linked list as a stack, as long as root is not empty, push it to stack, then set root to its left. when reaching to the most left child, start popping up, add reach root's value to result, and check if there is right child, if yes, push it to stack, till root is null AND stack is empty
3. Postorder traverse binary tree in non-recursive way: this is quite complicated, define a linked list as a stack, define a pre node and a current node, and using them to determine if the flow is going down in the tree or going up to the root, and then determine whether to push or pop. Also, need to use peek for current node before actually popping.
4. Preorder traverse binary tree in non-recursive way: define a linked list as a stack. when root not null or stack not empty, add root value to result, push root's left to stack. when root is null, pop root from stack and push root's right to stack. keep going till stack is empty and root is null.
5. max height of tree: first way to do it is to recursively find max height of left tree and right tree and plus 1. when root is null, return 0. The second way to do it is to use BFS, basically use queue to travere the tree level by level till it finishes and returns the final level.
6. min height of tree: can also be done in 2 ways. in recursive way, when root is null return 0, when left is null, return min height of right +1, when right is null, return min height of left + 1; if neither is null, return min(left min height and right min height) + 1. for non-recursive way, still using BFS, but need to check if a node is a leaf, if yes, return current level, that will be the min height
7. restore binary tree: there are 2 nodes in the tree that were swapped. if we inorder traverse the tree, pre node should always be smaller than current node. there could be 2 cases. one is the 2 node are next to each other, so the out-of-order happened once, and we can keep these 2 node and swap them at the end. in the other case, the 2 nodes are not next to each other, there will be 2 out-of-order pairs of nodes. we need to keep the first node in the first pair and the second node in the second pair and swap them at the end.
8. check if 2 trees are same: recursively traverse the trees (in any order) and keep checking current node. if both are null, return true; if one is null and the other is not, return false, if values of current nodes are not same, return false. if either left tree or right tree are not same, return false
9. sorted array to binary tree: check for edge cases. when array is null, return null, when its size is 1, return a new treenode from the only element. otherwise, create the root with the mid element and build left tree with left half and right tree with right half array.
10. symmetric tree: recursive way and non-recursive way. for recursive way, check edge case, if root is null return true. call recursive function of the left tree and right tree. in the recursive function, the roots of the 2 tree should be either both null or both non-null, and their values should be same; otherwise return false, then recursively check t1.left with t2.right, and t1.right with t2.left. For non-recursive way, we use 2 queues. for the checking on the root and its left and right, it's same as recursive way. then we put its left and right into the 2 queues. when we poll from 2 queues, we check on the 2 roots and their left and right (either both null or both non-null). then we put their left and right into queues (if not null), be careful about the order. if one puts left first, the other should be right first. 