1. Is tree balanced: recursive traverse. using a number to represent tree height. -1 is for unbalanced. when left or right is unbalanced, return -1. when height difference between left and right is bigger than 1, return -1; otherwise return max height of left and right plus 1. 
2. Inorder traverse binary tree in non-recursive way: use a linked list as a stack, as long as root is not empty, push it to stack, then set root to its left. when reaching to the most left child, start popping up, add reach root's value to result, and check if there is right child, if yes, push it to stack, till root is null AND stack is empty
3. Postorder traverse binary tree in non-recursive way: this is quite complicated, define a linked list as a stack, define a pre node and a current node, and using them to determine if the flow is going down in the tree or going up to the root, and then determine whether to push or pop. Also, need to use peek for current node before actually popping.
4. Preorder traverse binary tree in non-recursive way: define a linked list as a stack. when root not null or stack not empty, add root value to result, push root's left to stack. when root is null, pop root from stack and push root's right to stack. keep going till stack is empty and root is null.
5. max height of tree: first way to do it is to recursively find max height of left tree and right tree and plus 1. when root is null, return 0. The second way to do it is to use BFS, basically use queue to travere the tree level by level till it finishes and returns the final level.
6. min height of tree: can also be done in 2 ways. in recursive way, when root is null return 0, when left is null, return min height of right +1, when right is null, return min height of left + 1; if neither is null, return min(left min height and right min height) + 1. for non-recursive way, still using BFS, but need to check if a node is a leaf, if yes, return current level, that will be the min height
7. restore binary tree: there are 2 nodes in the tree that were swapped. if we inorder traverse the tree, pre node should always be smaller than current node. there could be 2 cases. one is the 2 node are next to each other, so the out-of-order happened once, and we can keep these 2 node and swap them at the end. in the other case, the 2 nodes are not next to each other, there will be 2 out-of-order pairs of nodes. we need to keep the first node in the first pair and the second node in the second pair and swap them at the end.
8. check if 2 trees are same: recursively traverse the trees (in any order) and keep checking current node. if both are null, return true; if one is null and the other is not, return false, if values of current nodes are not same, return false. if either left tree or right tree are not same, return false
9. sorted array to binary tree: check for edge cases. when array is null, return null, when its size is 1, return a new treenode from the only element. otherwise, create the root with the mid element and build left tree with left half and right tree with right half array.
10. symmetric tree: recursive way and non-recursive way. for recursive way, check edge case, if root is null return true. call recursive function of the left tree and right tree. in the recursive function, the roots of the 2 tree should be either both null or both non-null, and their values should be same; otherwise return false, then recursively check t1.left with t2.right, and t1.right with t2.left. For non-recursive way, we use 2 queues. for the checking on the root and its left and right, it's same as recursive way. then we put its left and right into the 2 queues. when we poll from 2 queues, we check on the 2 roots and their left and right (either both null or both non-null). then we put their left and right into queues (if not null), be careful about the order. if one puts left first, the other should be right first. 
11. find number of unique tree from an array of n unique numbers: check edge cases first. when there is no element or 1 element the answer is 1. with n numbers, the root can be any of them. we loop root node from index i=0 to i=n and add together all possible combinations of left tree and right tree. the number of trees when root is at i is: c(i) = c(i-1) * c(n-i), i = 0 to n. this can be through DP or recursive way. 
12. return all unique tress from an array of n unique numbers: use recursive way to find left trees and right trees for root at element i (i=1 to n), and then loop through both left trees and right trees and attach each of them to the root and add to the result. for the recursive function, it should take 2 parameters, one for the start element and the other for the end element, when end < start, return null. 
13. validating if a binary tree is valid: recursively traverse the tree and check using its definition. 1. traverse the tree in inorder, and maintain a previous node, recursively traverse left tree and then check current root value against previous node value, should be bigger than previous value, then recursively check the right tree, remember to update the previous node reference. 2. similar with the first way, instead of using a previous node reference, we use boundaries (left and right), all node in left tree should be smaller than root value and all values in right tree should be bigger than root value.
